{
  "id": "test3-c-cat-section-B",
  "title": "C-CAT Exam Test 3 - Section B (Hard)",
  "passingPercentage": 60,
  "correctMarks": 3,
  "incorrectMarks": 1,
  "sections": [
    {
      "id": "section-B-c-programming",
      "title": "C Programming",
      "questions": [
        {
          "id": 1,
          "text": "What will be the output of the following C code?",
          "codeSnippet": "#include <stdio.h>\nint main() {\n    int a = 5, b = 2;\n    printf(\"%d\", a+++b);\n    return 0;\n}",
          "options": [
            { "id": "a", "text": "7" },
            { "id": "b", "text": "8" },
            { "id": "c", "text": "Compilation error" },
            { "id": "d", "text": "Undefined behavior" }
          ],
          "correctOptionId": "a",
          "type": "syntax_semantics"
        },
        {
          "id": 2,
          "text": "In C, which of the following statements about function pointers is FALSE?",
          "options": [
            { "id": "a", "text": "Function pointers can be stored in arrays" },
            { "id": "b", "text": "Function pointers can be passed as arguments to functions" },
            { "id": "c", "text": "Function pointers can be dereferenced using the * operator" },
            { "id": "d", "text": "Function pointers cannot be compared for equality" }
          ],
          "correctOptionId": "d",
          "type": "advanced_concepts"
        },
        {
          "id": 3,
          "text": "What is the purpose of the 'volatile' keyword in C?",
          "options": [
            { "id": "a", "text": "To prevent compiler optimization on a variable" },
            { "id": "b", "text": "To make a variable constant" },
            { "id": "c", "text": "To allocate memory dynamically" },
            { "id": "d", "text": "To define a variable with automatic storage" }
          ],
          "correctOptionId": "a",
          "type": "memory_management"
        },
        {
          "id": 4,
          "text": "Which of the following is the correct way to declare a pointer to a function that takes two integers and returns an integer?",
          "options": [
            { "id": "a", "text": "int *func(int, int);" },
            { "id": "b", "text": "int (*func)(int, int);" },
            { "id": "c", "text": "int func*(int, int);" },
            { "id": "d", "text": "*int func(int, int);" }
          ],
          "correctOptionId": "b",
          "type": "pointers_functions"
        },
        {
          "id": 5,
          "text": "What will be the size of the following structure on a 64-bit system with typical alignment?",
          "codeSnippet": "struct test {\n    char a;\n    int b;\n    char c;\n    double d;\n};",
          "options": [
            { "id": "a", "text": "14 bytes" },
            { "id": "b", "text": "16 bytes" },
            { "id": "c", "text": "24 bytes" },
            { "id": "d", "text": "32 bytes" }
          ],
          "correctOptionId": "c",
          "type": "memory_alignment"
        },
        {
          "id": 6,
          "text": "What is the output of the following C code?",
          "codeSnippet": "#include <stdio.h>\nint main() {\n    int x = 10;\n    int *p = &x;\n    printf(\"%d\", ++*p);\n    printf(\"%d\", x);\n    return 0;\n}",
          "options": [
            { "id": "a", "text": "1010" },
            { "id": "b", "text": "1011" },
            { "id": "c", "text": "1111" },
            { "id": "d", "text": "1110" }
          ],
          "correctOptionId": "c",
          "type": "pointers"
        },
        {
          "id": 7,
          "text": "Which of the following is true about malloc() and calloc()?",
          "options": [
            { "id": "a", "text": "malloc() initializes memory to zero, calloc() doesn't" },
            { "id": "b", "text": "calloc() initializes memory to zero, malloc() doesn't" },
            { "id": "c", "text": "Both initialize memory to zero" },
            { "id": "d", "text": "Neither initializes memory to zero" }
          ],
          "correctOptionId": "b",
          "type": "dynamic_memory"
        },
        {
          "id": 8,
          "text": "What is the difference between 'const char *p' and 'char * const p'?",
          "options": [
            { "id": "a", "text": "First makes pointer constant, second makes data constant" },
            { "id": "b", "text": "First makes data constant, second makes pointer constant" },
            { "id": "c", "text": "Both make pointer constant" },
            { "id": "d", "text": "Both make data constant" }
          ],
          "correctOptionId": "b",
          "type": "const_pointers"
        },
        {
          "id": 9,
          "text": "What will be the output of the following code?",
          "codeSnippet": "#include <stdio.h>\nint main() {\n    char str[] = \"Hello\";\n    char *p = str;\n    printf(\"%c\", *(p+2));\n    return 0;\n}",
          "options": [
            { "id": "a", "text": "H" },
            { "id": "b", "text": "e" },
            { "id": "c", "text": "l" },
            { "id": "d", "text": "o" }
          ],
          "correctOptionId": "c",
          "type": "string_pointers"
        },
        {
          "id": 10,
          "text": "Which storage class has the longest lifetime in C?",
          "options": [
            { "id": "a", "text": "auto" },
            { "id": "b", "text": "register" },
            { "id": "c", "text": "static" },
            { "id": "d", "text": "extern" }
          ],
          "correctOptionId": "c",
          "type": "storage_classes"
        }
      ]
    },
    {
      "id": "section-B-data-structures",
      "title": "Data Structures",
      "questions": [
        {
          "id": 11,
          "text": "In a B-tree of order m, what is the maximum number of keys that can be stored in a node?",
          "options": [
            { "id": "a", "text": "m" },
            { "id": "b", "text": "m-1" },
            { "id": "c", "text": "m+1" },
            { "id": "d", "text": "2m-1" }
          ],
          "correctOptionId": "b",
          "type": "tree_structures"
        },
        {
          "id": 12,
          "text": "Which data structure is most suitable for implementing undo functionality in a text editor?",
          "options": [
            { "id": "a", "text": "Queue" },
            { "id": "b", "text": "Stack" },
            { "id": "c", "text": "Binary Tree" },
            { "id": "d", "text": "Hash Table" }
          ],
          "correctOptionId": "b",
          "type": "application_design"
        },
        {
          "id": 13,
          "text": "What is the worst-case time complexity for searching in a skip list?",
          "options": [
            { "id": "a", "text": "O(1)" },
            { "id": "b", "text": "O(log n)" },
            { "id": "c", "text": "O(n)" },
            { "id": "d", "text": "O(n log n)" }
          ],
          "correctOptionId": "c",
          "type": "complexity_analysis"
        },
        {
          "id": 14,
          "text": "In a Red-Black tree, what is the maximum possible height for a tree with n nodes?",
          "options": [
            { "id": "a", "text": "log n" },
            { "id": "b", "text": "2 log n" },
            { "id": "c", "text": "2 log(n+1)" },
            { "id": "d", "text": "n" }
          ],
          "correctOptionId": "c",
          "type": "balanced_trees"
        },
        {
          "id": 15,
          "text": "Which of the following operations on a Fibonacci heap has the best amortized time complexity?",
          "options": [
            { "id": "a", "text": "Insert" },
            { "id": "b", "text": "Find-min" },
            { "id": "c", "text": "Delete-min" },
            { "id": "d", "text": "Decrease-key" }
          ],
          "correctOptionId": "b",
          "type": "heap_structures"
        },
        {
          "id": 16,
          "text": "What is the space complexity of DFS (Depth First Search) algorithm?",
          "options": [
            { "id": "a", "text": "O(1)" },
            { "id": "b", "text": "O(V)" },
            { "id": "c", "text": "O(E)" },
            { "id": "d", "text": "O(V + E)" }
          ],
          "correctOptionId": "b",
          "type": "graph_algorithms"
        },
        {
          "id": 17,
          "text": "In which scenario would you prefer a linked list over an array?",
          "options": [
            { "id": "a", "text": "When you need random access to elements" },
            { "id": "b", "text": "When you need cache-friendly memory access" },
            { "id": "c", "text": "When you frequently insert/delete at arbitrary positions" },
            { "id": "d", "text": "When memory usage needs to be minimized" }
          ],
          "correctOptionId": "c",
          "type": "data_structure_selection"
        },
        {
          "id": 18,
          "text": "What is the minimum number of comparisons required to find both maximum and minimum elements in an array of n elements?",
          "options": [
            { "id": "a", "text": "n" },
            { "id": "b", "text": "2n-2" },
            { "id": "c", "text": "3n/2-2" },
            { "id": "d", "text": "2n" }
          ],
          "correctOptionId": "c",
          "type": "algorithm_optimization"
        },
        {
          "id": 19,
          "text": "Which data structure is best for implementing a LRU (Least Recently Used) cache?",
          "options": [
            { "id": "a", "text": "Array" },
            { "id": "b", "text": "Doubly Linked List + Hash Map" },
            { "id": "c", "text": "Binary Tree" },
            { "id": "d", "text": "Stack" }
          ],
          "correctOptionId": "b",
          "type": "cache_implementation"
        },
        {
          "id": 20,
          "text": "What is the time complexity of building a heap from an unsorted array using the bottom-up approach?",
          "options": [
            { "id": "a", "text": "O(n log n)" },
            { "id": "b", "text": "O(n²)" },
            { "id": "c", "text": "O(n)" },
            { "id": "d", "text": "O(log n)" }
          ],
          "correctOptionId": "c",
          "type": "heap_construction"
        }
      ]
    },
    {
      "id": "section-B-oop-cpp",
      "title": "Object Oriented Programming using C++",
      "questions": [
        {
          "id": 21,
          "text": "What is the output of the following C++ code?",
          "codeSnippet": "#include <iostream>\nusing namespace std;\nclass Base {\npublic:\n    virtual void func() { cout << \"Base\"; }\n};\nclass Derived : public Base {\npublic:\n    void func() override { cout << \"Derived\"; }\n};\nint main() {\n    Base* ptr = new Derived();\n    ptr->func();\n    return 0;\n}",
          "options": [
            { "id": "a", "text": "Base" },
            { "id": "b", "text": "Derived" },
            { "id": "c", "text": "Compilation error" },
            { "id": "d", "text": "Runtime error" }
          ],
          "correctOptionId": "b",
          "type": "virtual_functions"
        },
        {
          "id": 22,
          "text": "Which of the following statements about abstract classes in C++ is TRUE?",
          "options": [
            { "id": "a", "text": "A class with at least one pure virtual function is abstract" },
            { "id": "b", "text": "Abstract classes cannot have constructors" },
            { "id": "c", "text": "Abstract classes cannot have data members" },
            { "id": "d", "text": "Abstract classes cannot be inherited" }
          ],
          "correctOptionId": "a",
          "type": "abstract_classes"
        },
        {
          "id": 23,
          "text": "What is the difference between function overloading and function overriding?",
          "options": [
            { "id": "a", "text": "Overloading is compile-time, overriding is runtime" },
            { "id": "b", "text": "Overloading is runtime, overriding is compile-time" },
            { "id": "c", "text": "Both are compile-time" },
            { "id": "d", "text": "Both are runtime" }
          ],
          "correctOptionId": "a",
          "type": "polymorphism"
        },
        {
          "id": 24,
          "text": "In C++, what happens when you declare a destructor as virtual?",
          "options": [
            { "id": "a", "text": "It prevents inheritance" },
            { "id": "b", "text": "It ensures proper cleanup in inheritance hierarchies" },
            { "id": "c", "text": "It makes the class abstract" },
            { "id": "d", "text": "It prevents object creation" }
          ],
          "correctOptionId": "b",
          "type": "virtual_destructors"
        },
        {
          "id": 25,
          "text": "Which of the following best describes the RAII principle in C++?",
          "options": [
            { "id": "a", "text": "Resource Allocation Is Inheritance" },
            { "id": "b", "text": "Resource Acquisition Is Initialization" },
            { "id": "c", "text": "Runtime Analysis and Interpretation Idiom" },
            { "id": "d", "text": "Recursive Allocation of Instance Information" }
          ],
          "correctOptionId": "b",
          "type": "design_principles"
        },
        {
          "id": 26,
          "text": "What is the purpose of the 'explicit' keyword in C++?",
          "options": [
            { "id": "a", "text": "To prevent implicit type conversions" },
            { "id": "b", "text": "To make functions inline" },
            { "id": "c", "text": "To declare virtual functions" },
            { "id": "d", "text": "To enable template specialization" }
          ],
          "correctOptionId": "a",
          "type": "cpp_keywords"
        },
        {
          "id": 27,
          "text": "Which of the following is true about copy constructors in C++?",
          "options": [
            { "id": "a", "text": "They are always provided by the compiler" },
            { "id": "b", "text": "They perform shallow copy by default" },
            { "id": "c", "text": "They can be declared as virtual" },
            { "id": "d", "text": "They must always be explicitly defined" }
          ],
          "correctOptionId": "b",
          "type": "copy_constructors"
        },
        {
          "id": 28,
          "text": "What is the output of the following C++ code?",
          "codeSnippet": "#include <iostream>\nusing namespace std;\nclass A {\npublic:\n    A() { cout << \"A\"; }\n    ~A() { cout << \"~A\"; }\n};\nint main() {\n    A a;\n    return 0;\n}",
          "options": [
            { "id": "a", "text": "A" },
            { "id": "b", "text": "~A" },
            { "id": "c", "text": "A~A" },
            { "id": "d", "text": "~AA" }
          ],
          "correctOptionId": "c",
          "type": "constructor_destructor"
        },
        {
          "id": 29,
          "text": "Which of the following access specifiers allows access from derived classes but not from outside the class?",
          "options": [
            { "id": "a", "text": "public" },
            { "id": "b", "text": "private" },
            { "id": "c", "text": "protected" },
            { "id": "d", "text": "friend" }
          ],
          "correctOptionId": "c",
          "type": "access_specifiers"
        },
        {
          "id": 30,
          "text": "What is the difference between 'new' and 'malloc' in C++?",
          "options": [
            { "id": "a", "text": "new calls constructors, malloc doesn't" },
            { "id": "b", "text": "malloc calls constructors, new doesn't" },
            { "id": "c", "text": "Both call constructors" },
            { "id": "d", "text": "Neither calls constructors" }
          ],
          "correctOptionId": "a",
          "type": "memory_allocation"
        }
      ]
    },
    {
      "id": "section-B-operating-systems",
      "title": "Operating Systems & Networking",
      "questions": [
        {
          "id": 31,
          "text": "In the context of deadlock prevention, which of the following techniques involves ensuring that processes request resources in a specific order?",
          "options": [
            { "id": "a", "text": "Wait-Die scheme" },
            { "id": "b", "text": "Wound-Wait scheme" },
            { "id": "c", "text": "Resource ordering" },
            { "id": "d", "text": "Banker's algorithm" }
          ],
          "correctOptionId": "c",
          "type": "deadlock_prevention"
        },
        {
          "id": 32,
          "text": "Which page replacement algorithm suffers from Belady's anomaly?",
          "options": [
            { "id": "a", "text": "LRU (Least Recently Used)" },
            { "id": "b", "text": "FIFO (First In First Out)" },
            { "id": "c", "text": "Optimal" },
            { "id": "d", "text": "LFU (Least Frequently Used)" }
          ],
          "correctOptionId": "b",
          "type": "memory_management"
        },
        {
          "id": 33,
          "text": "In TCP, what is the purpose of the sliding window protocol?",
          "options": [
            { "id": "a", "text": "Error detection" },
            { "id": "b", "text": "Flow control and reliability" },
            { "id": "c", "text": "Routing optimization" },
            { "id": "d", "text": "Congestion avoidance only" }
          ],
          "correctOptionId": "b",
          "type": "networking_protocols"
        },
        {
          "id": 34,
          "text": "Which scheduling algorithm can lead to starvation of long processes?",
          "options": [
            { "id": "a", "text": "Round Robin" },
            { "id": "b", "text": "First Come First Served" },
            { "id": "c", "text": "Shortest Job First" },
            { "id": "d", "text": "Priority scheduling with aging" }
          ],
          "correctOptionId": "c",
          "type": "process_scheduling"
        },
        {
          "id": 35,
          "text": "In the OSI model, which layer is responsible for end-to-end communication and error recovery?",
          "options": [
            { "id": "a", "text": "Network Layer" },
            { "id": "b", "text": "Transport Layer" },
            { "id": "c", "text": "Session Layer" },
            { "id": "d", "text": "Data Link Layer" }
          ],
          "correctOptionId": "b",
          "type": "network_architecture"
        },
        {
          "id": 36,
          "text": "What is the main advantage of using semaphores over mutex locks?",
          "options": [
            { "id": "a", "text": "Semaphores are faster" },
            { "id": "b", "text": "Semaphores can count resources" },
            { "id": "c", "text": "Semaphores prevent deadlocks" },
            { "id": "d", "text": "Semaphores use less memory" }
          ],
          "correctOptionId": "b",
          "type": "synchronization"
        },
        {
          "id": 37,
          "text": "In virtual memory systems, what is thrashing?",
          "options": [
            { "id": "a", "text": "Excessive page swapping" },
            { "id": "b", "text": "Memory fragmentation" },
            { "id": "c", "text": "Cache misses" },
            { "id": "d", "text": "Process starvation" }
          ],
          "correctOptionId": "a",
          "type": "virtual_memory"
        },
        {
          "id": 38,
          "text": "Which network topology provides the highest fault tolerance?",
          "options": [
            { "id": "a", "text": "Bus" },
            { "id": "b", "text": "Star" },
            { "id": "c", "text": "Ring" },
            { "id": "d", "text": "Mesh" }
          ],
          "correctOptionId": "d",
          "type": "network_topology"
        },
        {
          "id": 39,
          "text": "What is the purpose of the Translation Lookaside Buffer (TLB)?",
          "options": [
            { "id": "a", "text": "To cache disk blocks" },
            { "id": "b", "text": "To cache page table entries" },
            { "id": "c", "text": "To cache CPU instructions" },
            { "id": "d", "text": "To cache network packets" }
          ],
          "correctOptionId": "b",
          "type": "memory_management"
        },
        {
          "id": 40,
          "text": "In the context of distributed systems, what is the CAP theorem about?",
          "options": [
            { "id": "a", "text": "Consistency, Availability, and Partition tolerance" },
            { "id": "b", "text": "Concurrency, Atomicity, and Persistence" },
            { "id": "c", "text": "Capacity, Availability, and Performance" },
            { "id": "d", "text": "Caching, Authentication, and Privacy" }
          ],
          "correctOptionId": "a",
          "type": "distributed_systems"
        }
      ]
    },
    {
      "id": "section-B-big-data-ai",
      "title": "Big Data & Artificial Intelligence",
      "questions": [
        {
          "id": 41,
          "text": "In the context of Big Data, what does the 'Variety' characteristic primarily refer to?",
          "options": [
            { "id": "a", "text": "The speed at which data is generated" },
            { "id": "b", "text": "The amount of data being processed" },
            { "id": "c", "text": "Different types and formats of data" },
            { "id": "d", "text": "The accuracy and quality of data" }
          ],
          "correctOptionId": "c",
          "type": "big_data_concepts"
        },
        {
          "id": 42,
          "text": "Which of the following is NOT a characteristic of the MapReduce programming model?",
          "options": [
            { "id": "a", "text": "Fault tolerance" },
            { "id": "b", "text": "Parallel processing" },
            { "id": "c", "text": "Real-time processing" },
            { "id": "d", "text": "Scalability" }
          ],
          "correctOptionId": "c",
          "type": "mapreduce_hadoop"
        },
        {
          "id": 43,
          "text": "In machine learning, what is the primary purpose of cross-validation?",
          "options": [
            { "id": "a", "text": "To increase the size of the training dataset" },
            { "id": "b", "text": "To assess model performance and prevent overfitting" },
            { "id": "c", "text": "To reduce the dimensionality of data" },
            { "id": "d", "text": "To clean and preprocess the data" }
          ],
          "correctOptionId": "b",
          "type": "machine_learning"
        },
        {
          "id": 44,
          "text": "Which of the following algorithms is commonly used for clustering in unsupervised learning?",
          "options": [
            { "id": "a", "text": "Linear Regression" },
            { "id": "b", "text": "Decision Trees" },
            { "id": "c", "text": "K-means" },
            { "id": "d", "text": "Support Vector Machines" }
          ],
          "correctOptionId": "c",
          "type": "unsupervised_learning"
        },
        {
          "id": 45,
          "text": "In the context of neural networks, what is the vanishing gradient problem?",
          "options": [
            { "id": "a", "text": "When gradients become too large during backpropagation" },
            { "id": "b", "text": "When gradients become very small in deep networks" },
            { "id": "c", "text": "When the network fails to converge" },
            { "id": "d", "text": "When the learning rate is too high" }
          ],
          "correctOptionId": "b",
          "type": "deep_learning"
        },
        {
          "id": 46,
          "text": "What is the main advantage of Apache Spark over Hadoop MapReduce?",
          "options": [
            { "id": "a", "text": "Better fault tolerance" },
            { "id": "b", "text": "In-memory processing capabilities" },
            { "id": "c", "text": "Lower storage requirements" },
            { "id": "d", "text": "Simpler programming model" }
          ],
          "correctOptionId": "b",
          "type": "big_data_frameworks"
        },
        {
          "id": 47,
          "text": "In supervised learning, what is the difference between classification and regression?",
          "options": [
            {
              "id": "a",
              "text": "Classification predicts continuous values, regression predicts discrete values"
            },
            {
              "id": "b",
              "text": "Classification predicts discrete values, regression predicts continuous values"
            },
            { "id": "c", "text": "Both predict continuous values" },
            { "id": "d", "text": "Both predict discrete values" }
          ],
          "correctOptionId": "b",
          "type": "ml_fundamentals"
        },
        {
          "id": 48,
          "text": "What is the purpose of feature scaling in machine learning?",
          "options": [
            { "id": "a", "text": "To increase the number of features" },
            {
              "id": "b",
              "text": "To ensure all features contribute equally to distance calculations"
            },
            { "id": "c", "text": "To remove irrelevant features" },
            { "id": "d", "text": "To create new features from existing ones" }
          ],
          "correctOptionId": "b",
          "type": "feature_engineering"
        },
        {
          "id": 49,
          "text": "In the context of Hadoop ecosystem, what is the primary function of HDFS?",
          "options": [
            { "id": "a", "text": "Data processing" },
            { "id": "b", "text": "Distributed storage" },
            { "id": "c", "text": "Resource management" },
            { "id": "d", "text": "Data visualization" }
          ],
          "correctOptionId": "b",
          "type": "hadoop_ecosystem"
        },
        {
          "id": 50,
          "text": "Which activation function is most commonly used in hidden layers of deep neural networks?",
          "options": [
            { "id": "a", "text": "Sigmoid" },
            { "id": "b", "text": "Tanh" },
            { "id": "c", "text": "ReLU" },
            { "id": "d", "text": "Linear" }
          ],
          "correctOptionId": "c",
          "type": "neural_networks"
        }
      ]
    }
  ]
}
